% Copyright 2021 Jacopo Maltagliati
%
% Use of this source code is governed by an EUPL-style
% license that can be found in the LICENSE file or at
% https://eupl.eu/1.2/en/.
% A localized copy of this license can be found in the LICENSE.it file or at
% https://eupl.eu/1.2/it/
%
% Portions of this document are subject to different licensing agreements,
% see src/titlepage.tex for details.

\documentclass[a4paper,12pt]{report}
\usepackage[paper=a4paper,margin=1in]{geometry}
\usepackage{graphicx}
%\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
\usepackage[english]{babel}
%\usepackage{amssymb}
%\usepackage{amsthm}
%\usepackage{amsmath}
%\usepackage{amstext}
\usepackage{microtype}
\usepackage{csquotes}
\usepackage{bookmark}
\usepackage{xpatch}
\usepackage[backend=biber, sorting=none]{biblatex}
\addbibresource{all.bib}
\usepackage[color=green,textsize=tiny]{todonotes}
\usepackage{sectsty}
\chapternumberfont{\large}
\chaptertitlefont{\huge}
\renewcommand{\familydefault}{\sfdefault}
\begin{document}
% Titlepage
\input{titlepage.tex}
\newpage
% Quote
\vspace*{\stretch{1}}
\begin{flushright}
  \itshape
  \begin{tabular}{@{}l@{}}
    Sample Text \\
    Sample Text
  \end{tabular}
\end{flushright}
\vspace{\stretch{2}}
\newpage
% Toc
\tableofcontents
\newpage
% Ch1
\chapter{Summary}

In the past ten years, mobile robotics as a field has been gaining a lot of traction: as technology evolves, building a mobile platform has become more and more feasible for anyone, including small research teams and hobbyists. However, there is still a lack of easily approachable real-time solutions able to manage the workload, as many of the available frameworks are not mature enough to offer fine-grained real time application control: this is why we ultimately decided to push the Linux kernel to its limits, studying its real-time capabilities and ease of use.

\section{The problem}

Imagine driving on an empty road at night while listening to classical music: it's been a very long day, and your consciousness gradually drifts to a peaceful slumber. Suddenly, an animal crosses the road: are you going to notice? Will you be able to stop in time? Now, consider a self-driving car in the same situation: what would happen if the control computer "dozed off" even for a fraction of a second? The user would probably not be able to stomp on the brakes fast enough to prevent the car from crashing.

A possible solution to this problem is carefully designing a system built around existing technologies, such as real-time control, redundant hardware platforms, and failsafe mechanisms. However, creating a real-time system from the ground up tends to be very expensive and error-prone, as incorrect design or minor mistakes could lead to catastrophic failures such as the infamous Therac\cite{therac-25-accidents} incidents.

For this reason, many software houses have been working on various commercial solutions since the 1980s that enabled programmers and engineers to deploy their application on proven grounds, thus reducing the time and effort needed to create a real-time application. Arguably, the best aspect of those systems was their widespread availability: for example, DEC's VAXeln used lightly modified VAX computers, and Quantum Computer Inc. QNX ran on consumer-grade hardware, including x86 processors. While the VAXeln is now a historical platform, QNX is still commercially available from BlackBerry Inc. and major companies such as Apple use it for their products\cite{time-carplay-qnx}.

However, having always demonstrated an incredible flexibility, the ubiquitous Linux kernel is becoming a viable option for robotics and real-time usage, with both academic and commercial applications exploiting it like Tesla Motors, which maintains its own fork\cite{gh-tesla-linux}.

Of course, this flexibility comes at the cost of reduced effectiveness in each specific situation, so why do both academic and commercial researchers decide to use Linux? For example:
\begin{itemize}
  \item Linux is free and comes at no cost.
  \item Linux is open-source, so it might be tailored to specific needs
        with the right expertise.
  \item Linux has a wide community of people constantly improving it,
        ensuring constant updates without any support contract.
\end{itemize}

This is why, despite the shortcomings of the Linux kernel, we decided to adopt it for this project.

\section{Current Implementation}

At the moment, most of IRAlab's mobile platforms are controlled by a master node running Ubuntu Linux 16.04 LTS and the ROS framework. The ROS (Robot Operating System) framework is an open-source middleware, that is a set of software libraries and tools that help you build robot applications. ROS was created by Willow Garage as a rapid development platform for their PR2 robot and traces its roots into an even earlier effort by a team of researchers and students at Stanford University.

Despite its name, ROS needs a host operating system: at the time of writing, it can run on either Linux, Windows or macOS, but since the behavior of each platform has notable differences, we'll focus only on the ROS/Linux combination. Please also note that ROS and ROS2 will be treated as separate entities throughout this report.

\subsection{Description}

Currently, the navigation stacks uses mainly uses ROS for abstraction and rapid prototyping: through the use of \textit{topics} and \textit{messages}, ROS provides a facility to let the users write small programs, called nodes, and make them communicate with each other. A master node, provided by the framework, acts as a central hub, keeping tabs on the state of the \textit{Computational Graph}. Moreover, ROS provides extensive timestamping and data logging facilities, letting the user easily track, monitor and simulate a mobile platform's behavior.

An in-depth analysis of the ROS functionalities and usage in an IRAlab mobile platform is outside the scope of this report, but it's received extensive coverage in works performed by Gerosa* and Di Lauro*.

\subsection{Issues}

The problem with ROS is, simply put, its clunkyness: while it's a very good rapid prototyping platform, there is no way to control the way that the whole thing is scheduled besides modifying the source code extensively, which would be an incredibly complex task. The authors of the software have acknowledged those problems themselves*<prt authors> and set out to release a newer, real-time friendly version of the platform.

%% which problems does ros bring to the table
\begin{itemize}
    \item Precisely controlling timing in ROS is next to impossible due to the fact that the tasks in ROS are controlled by the master node
    \item Many parts of ROS are written in Python, an interpreted (or rather JIT-compiled) language. This class of languages are notoriously hard to control in real-time environments
\end{itemize}

\section{Possible Solutions}

To achieve precise real-time control of our application we decided to explore the capabilities of the RT patch, which greatly reduces the latency of the Linux kernel, thus giving the programmer more control on the timing of a real-time application.

\subsection{\texttt{PREEMPT\_RT}}

%% brief history of p-rt: who's behind it?
\texttt{PREEMPT\_RT} is a patch for the Linux kernel introduced in 2005 with the goal of reducing the latency and increasing the determinism of the kernel\cite{survey-preempt-rt}. One side effect of this patch was dramatically improving the performance of the MP implementation*<prt authors>.

%% how does preempt-rt work?
PRT works by... (two-tier architecture, ...)

%% how can we determine the benefits of preempt-rt?
The benefits of PRT are invaluable: at the cost of throughput, unbounded latencies are virtually eliminated and the performance benefits are immense*<tesi poliTO>.

\subsection{ROS2}

%% TODO check ros2 toy and release
ROS version 2 is the new generation of the ROS platform, which at the time of writing has been undergoing development since 20xx and is now at release x.

%% what are the benefits of using ros2?
ROS2 has been designed with real time constraints in mind to solve the shortcomings of ROS. ROS2 pipelines tasks in a very different way and uses an enterprise-grade communications subsystem that is much more RT-friendly. ROS2 uses a single process to control and schedule tasks, spawning them as threads.

%% why would keeping ros be important?
Keeping ROS would've enabled us to benefit from real-time improvements without the burden of porting the whole application stack to a new platform, thus reducing turnaround time significantly. 

%% why did we rule out ros2 entirely?
In the end, we decided that ROS2 would not give us precise enough control on RT constraints because since the tasks are scheduled by an algorithm internal to ros2*<ros2 internals>, it's impossible for us to schedule single tasks with an RT-scheduler provided by Linux such as RT or EDF. 

\subsection{\texttt{SCHED\_EDF}}

%% brief history of sched-edf and who's behind it
SCHED\_EDF is a scheduler developed by <! inserire nomi qui> that's been available since Kernel <!versione linux qui>. The EDF scheduler allows the programmer to define and schedule tasks in the highest possible scheduling class <vedi capitolo classi scheduling> with an Earlier Deadline First" algorithm. The programmer must define:

\begin{itemize}
    \item A period, that is the time after which the task repeats itself (or rather the scheduler does)
    \item A deadline, that is the time after which the task has taken too long to complete
    \item A runtime, that is the WCET of the task
\end{itemize}

The CBS algorithm is used in conjunction with EDF for...
\todo{Dig up details about CBS}

%% how does sched-edf work
The algorithms behind SCHED\_EDF are described by *<abeni, buttazzo>.

\subsubsection{Scheduling classes in Linux}

Scheduling classes in Linux are a system to provide different scheduling algorithms for different kinds of tasks while maintaining a specific hierarchy 

%% scheduling priority
The priority of the various scheduling classes is as follows:
STOP > DL > RT > CFS > IDLE > NULL

CFS replaced the older O(1) scheduler as the default scheduler in <!kernel version, year> Refer to *<sched(7)>.

\newpage
% Ch2
\chapter{Solution}

Our custom solution, dubbed \texttt{rt-app} (as in Real-Time Application) is a demonstration of a viable approach for building real-time applications on Linux.

Written from scratch, the application currently leverages several APIs provided by Linux such as sched, time and pthreads.

\section{Design}

\texttt{rt-app}'s design is based around some components which are regarded as standard in the mobile robotics field, such as:
\begin{itemize}
  \item The global planner: a component that keeps track
  \item The local planner: a component responsible for tracking
  \item AMCL:
  \item The costmap:
  \item odometry: a component that constantly elaborates the data received from various sources, such as the move base's wheel encoders, to keep track of where the robot is going.
\end{itemize}

Moreover, the following components have been envisioned:
\begin{itemize}
  \item The pose manager, which is a pivotal component that manages the lifecycle of a pose, its duty is to control the flow of poses going from odometry to the local planner and backfeed adjusted poses coming from AMCL.
  \item The dispatcher, which takes care of initializing threads and resources, and is responsible for terminating the application once all workers have finished their job.
\end{itemize}

Most of these operations are to be performed on-line, that is in a real-time fashion, except for global planning and thread dispatching, both of which happen once, when the dispatcher sets the modules up.

\subsection{Rationale}

The main goal behind \texttt{rt-app}, however, is demonstrating that replicating a ROS-like behavior is possible by only using facilities provided by the Linux kernel and the GNU stdlib: thus, in the following sections we'll focus more on the implementation rather than the design process.

\subsection{Planning}

Given that the work required to implement such a complex application can't be possibly condensed in such a short timeframe, we've settled for splitting the work in several phases:
\begin{itemize}
  \item Phase 1: High level design and survey of the possible solutions
  \item Phase 2: Implementation of the dispatcher, at least one of the modules and integration with an existing mobile platform.
  \item Phase 3: Maintenance and gradual addition of more modules, according to the programming guidelines and general architecture set by the work performed in phase 2.
\end{itemize}

Thus far, Phase 1 and a consistent portion of Phase 2 have been completed: the Odometry module has been implemented, on top of a simple dispatcher based on \texttt{pthreads} and \texttt{SCHED\_EDF}. IRAlab's Otto* mobile platform has been selected to be the test candidate, thus the Odometry module has been interfaced with a microcontroller emulating the protocol and message format used by Otto. The nature of this emulation will be discussed in a later paragraph. %% can I link the paragraph?

\section{Implementation}
\subsection{Threads}

Threads are used for running \b{modules}, which are separately scheduled units of the application that interact with each other via IPC methods. Modules, in turn, can use \b{adapters} to communicate with peripherals and \b{helpers} for housekeeping tasks.

\subsection{Scheduling}

Each module schedules itself. \todo{This might change in the future!}

\subsection{Timing}

Timing is a critical part of the application

\subsection{Communications}
\subsubsection{Serial}

The application talks to the movebase via serial (UART) comms over /dev/ttyUSB0 at 115200 Baud using the \texttt{a\_otto.\{c,h\}} adapter.

\subsection{Shared memory}

Not implemented.

\section{Future Development}

\begin{itemize}
    \item More modules
    \item Better separation of tasks
    \item Code deduplication
\end{itemize}

\newpage
% Ch3
\chapter{Implementation Issues <???>}
\section{Patching and building the kernel}

http://kernel-notes.gbittencourt.net/compiling-preempt-rt/

\begin{itemize}
    \item Download https://git.kernel.org/pub/scm/linux/kernel/git/rt/linux-stable-rt.git/tag/?h=v5.4.74-rt41-rebase and untar (~900MB of sources) and cd
    \item \texttt{cp /boot/config-\$(uname -r) .config}
    \item \texttt{make olddefconfig}
    \item \texttt{make -j \$(nproc) deb-pkg}
    \item Wait ~4Hrs
    \item Install the deb pkgs and reboot
\end{itemize}

\section{Emulating the mobile platform}

Simulating IRAlab's Otto mobile platform's comms stack with an ESP8266 (NodeMCU "amica" 1.0) and
providing dummy data to \href{https://github.com/iralabdisco/rt-app}{rt-app}'s odometry module for testing. Using nanopb for comms over a serial line over USB (UART) running at 115200 baud. 

\todo{Describe otto266 better}

\section{Processor features that are detrimental to RT performance}

\begin{itemize}
    \item Caches
    \item CPU Threads (SMT)
    \item CPU Cores (SMP)
    \item Intel Management Engine (ME) and AMD Secure Platform (PSP)
    \item Power saving states, suspension, hybernation and clock boost
\end{itemize}

\section{Logging}

Logging was implemented with syslog() and it's got better performance than printf() logging, besides it can make use of system logs and be easily trackable with tools like journalctl. Refer to *<article that says that printf is worse than syslog>

\section{Filesystem}

I'm not sure I'm keeping this section as it's pretty hard to find reputable sources, but it's a nice thing to do anyway. 

\section{Notes on CPUSETS} %% maybe it's better off here?

CPUSETS solve the problem of SMP (and SMT, to some extent) by locking specific processes (as in thread groups) to a partition of the available processors (or cores).

\todo{Explain how CPUSETS work with a code example}

% Tail
\printbibliography
\end{document}




